{"data":{"markdownRemark":{"html":"<p>调用栈是解释器（就像浏览器中的javascript解释器）追踪函数执行流的一种机制。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。</p>\n<ul>\n<li>每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。</li>\n<li>正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。</li>\n<li>当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。</li>\n<li>当分配的调用栈空间被占满时，会引发“堆栈溢出”。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// [1] Some codes here</span>\n   <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token comment\">// [2] Some codes here</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">function</span> <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span>   <span class=\"token keyword\">return</span> <span class=\"token string\">\"Hi!\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 调用 `greeting` 函数</span>\n<span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// [3] Some codes here</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面的代码将这样执行:</p>\n<ol>\n<li>忽略前面所有函数，直到greeting()函数被调用。</li>\n<li>把greeting()添加进调用栈列表。</li>\n<li>执行greeting()函数体中的所有代码。</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">调用栈列表:\n  greeting</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<ol start=\"4\">\n<li>代码执行到sayHi()时，该函数被调用。</li>\n<li>把sayHi()添加进调用栈列表。</li>\n<li>执行sayHi()函数体中的代码，直到全部执行完毕。</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">调用栈列表:\n  greeting\n  sayHi</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<ol start=\"7\">\n<li>返回来继续执行greeting()函数体中sayHi()后面的代码。</li>\n<li>删除调用栈列表中的sayHi()函数。</li>\n<li>当greeting()函数体中的代码全部执行完毕，返回到调用greeting()的代码行，继续执行剩余JS代码。</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">调用栈列表:\n  greeting</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<ol start=\"10\">\n<li>删除调用栈列表中的greeting()函数。</li>\n</ol>\n<p>一开始，我们得到一个空空如也的调用栈。随后，每当有函数被调用都会自动地添加进调用栈，执行完函数体中的代码后，调用栈又会自动地移除这个函数。最后，我们又得到了一个空空如也的调用栈。</p>","excerpt":"调用栈是解释器（就像浏览器中的javascript…","frontmatter":{"title":"调用栈","description":"","date":"三月 01, 2019"},"fields":{"slug":"/posts/call_stack/"}}},"pageContext":{"slug":"/posts/call_stack/"}}